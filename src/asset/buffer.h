/*
   in this demo, we are going to support the following list of buffer objects:

   - VBO  (Vertex Buffer Object)
   - IBO  (Index Buffer Object)
   - PBO  (Pixel Buffer Object)
   - ATC  (Atomic Counters)
   - UBO  (Uniform Buffer Object)
   - SSBO (Shader Storage Buffer Object)

   note that those below are not buffer objects so do not fall into this category:

   - VAO  (Vertex Array Object)
   - FBO  (Framebuffer Object)
   - RBO  (Renderbuffer Object)
   - ILS  (Image Load Store)
   - TFB  (Transform Feedback)
   - TBO  (Texture Buffer Object)
   - ......

   since OpenGL 4.5, direct state access has been introduced into the core profile, with DSA
   at out disposal, we can now easily modify, read, write or setup data for buffers without
   having to bind them. Whenever possible, we'll use DSA call to keep code clean. Previously
   without DSA, we'd have to bind a buffer before changing its state, unbind once we're done
   and possibly restore all the read and write targets, but these are no longer required.

   for buffer objects, the presence of DSA has also eliminated the need for `glBindBuffer()`
   for instance, since there's only one target for each of VBO, IBO and PBO, we can identify
   them using the object's handle id without causing ambiguity. For indexed buffers like UBO
   and SSBO, the binding point in GLSL is unique so we only need to bind them once or reset
   the index occasionally. Also, we'll use immutable data store as much as possible.

   # OOP inheritance

   the base class must follow the rule of five, with a virtual destructor, the derived class
   does not have to explicitly declare the destructor or copy/move constructor, because they
   will be generated by the compiler to match the rule of five in the base class, but if one
   of them has been declared, then all others have to be explicitly declared as well.

   # UBO creation

   uniform buffers are often complex so it has a special constructor. Instead of setting up
   each member manually, we can just pass in a shader and uniform block id (a unique binding
   point), and it's going to figure out the block's structure automatically, including all
   the byte sizes, strides and paddings of each individual uniform element.

   # SSBO vs UBO

   SSBOs are mostly used as data buffers in the compute shader, their most typical use cases
   are: particle systems, water simulation and some physics. For computations that naturally
   fit onto a 2D Grid, you can also use ILS (image load store), but the advantage of SSBO is
   that it can store much much more data (>= 128 MB).

   from an abstract point of view, SSBOs are tightly packed one-dimensional arrays, or the
   flattened array of a higher dimensional compute space. Each element in the array directly
   maps to an invocation in the compute space, this relation can be derived from the number
   and size of work groups and local invocation id.

   SSBOs are often used to store much larger data (up to 128 MB), UBOs are limited to 16KB.
   SSBOs can save more memory space using `std430`, there's no need to pack data arrays.
   SSBOs are slower to access in GLSL, wheras UBOs are blazingly fast.
   SSBOs allow read/write in both C++ and GLSL, UBOs are read-only in GLSL.

   also, sometimes it's more convenient to update SSBO memory directly in C++, this can be
   done by mapping the buffer pointer to the client address space, just make sure that the
   memory barrier has been properly handled so that reads and writes are visible. Also note
   that SSBO will be in a lock state while the data store is mapped to C++, it can't be used
   by OpenGL until the pointer is released (except persistent mapping).

   # padding issues

   when using UBO and SSBO, we need to follow some rules so that they can work properly. The
   UBO class assumes that every uniform block in GLSL uses the `std140` layout, and the SSBO
   class assumes a similar `std430` layout. `std430` is more widely used for SSBOs because
   the base alignment and stride of an array element is not rounded up to the size of a vec4
   which means that even `float[]` will be tightly packed.

   in this demo, we'll limit the data types in UBO and SSBO to only scalars, 2-element or 4-
   element vectors and matrices, or arrays of them. To be clear, we'll not allow any double
   data types such as dvec4, dmat2, or any user-defined struct types. In terms of structs,
   nested non-basic types will only add complexity to our code base, w/o any benefit, so we
   should always replace them with two or more basic types.

   the reason for this is that 3-element types are error-prone, implementation of 3-element
   paddings is often buggy on many drivers, also they are less performant than the 4-element
   equivalents. Meanwhile, double precision data types is an overkill for most applications,
   they make no difference on a 1080p screen so can be safely ignored. Now, based on these
   assumptions, the above memory layouts are much easier to work with, even for arrays:

   - for `std140`, an array element is always padded to the size of a vec4 (4N = 16 bytes)
   - for `std430`, an array element is always padded to the base alignment of its data type

   # data packs

   for efficient use of memory, it is best to pack pieces of data into 4-element vectors as
   much as possible, then access each piece of data separately using the `xyzw` swizzling
   trick (e.g. pack a vec3 + a float into a vec4). For elements in arrays under `std140`,
   this is mandatory rather than a suggestion because an element is always padded to a vec4.

   for instance, float[] and ivec2[] in C++ cannot be directly passed to the UBO since they
   are laid out differently in the GPU memory. On CPU side, we have to either pad them to a
   vec4 (in which case more than half of the memory space is wasted), or pack every 4 floats
   or 4 integers (4 bytes x 4 = 16 bytes) into one vec4 (no memory space is wasted). To do
   so we can just use C-style arrays, but `std::vector` will be a better option because it's
   not only tightly packed in contiguous memory, but also provides a lot more robustness.

   caution: avoid using boolean types, use integers instead! Booleans are dangerous because
   std::vector<bool> is not really a standard STL container, for space-optimization reasons,
   the C++ standard actually requires each bool to take up only 1 byte instead of 4, so if
   we were to pass a boolean from C++ to GLSL, we have to cast it to int/uint in all cases.

   in the context of SSBO, packing data is even more important as SSBOs are intended to hold
   much more data, so memory space becomes the major concern for efficiency and performance.
   for struct, we should break it and store each element in a separate SSBO, thus every SSBO
   will be a tightly-packed homogeneous buffer array.
*/

#pragma once

#include <vector>
#include <glad/glad.h>

namespace asset {

    class IBuffer {
      protected:
        GLuint id;
        GLsizeiptr size;
        mutable void* data_ptr;

        IBuffer();
        IBuffer(GLsizeiptr size, const void* data, GLbitfield access);
        virtual ~IBuffer();

        IBuffer(const IBuffer&) = delete;
        IBuffer& operator=(const IBuffer&) = delete;
        IBuffer(IBuffer&& other) noexcept;
        IBuffer& operator=(IBuffer&& other) noexcept;

      public:
        GLuint ID() const { return this->id; }
        GLsizeiptr Size() const { return this->size; }
        void* const Data() const { return this->data_ptr; }

        static void Copy(GLuint fr, GLuint to, GLintptr fr_offset, GLintptr to_offset, GLsizeiptr size);

        void GetData(void* data) const;
        void GetData(GLintptr offset, GLsizeiptr size, void* data) const;
        void SetData(const void* data) const;
        void SetData(GLintptr offset, GLsizeiptr size, const void* data) const;

        void Acquire(GLbitfield access) const;
        void Release() const;
        void Clear() const;
        void Clear(GLintptr offset, GLsizeiptr size) const;
        void Flush() const;
        void Flush(GLintptr offset, GLsizeiptr size) const;
        void Invalidate() const;
        void Invalidate(GLintptr offset, GLsizeiptr size) const;
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////

    class VBO : public IBuffer {
      public:
        VBO(GLsizeiptr size, const void* data, GLbitfield access = 0) : IBuffer(size, data, access) {}
    };

    class IBO : public IBuffer {
      public:
        IBO(GLsizeiptr size, const void* data, GLbitfield access = 0) : IBuffer(size, data, access) {}
    };

    class PBO : public IBuffer {
      public:
        PBO(GLsizeiptr size, const void* data, GLbitfield access = 0) : IBuffer(size, data, access) {}
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////

    class IIndexedBuffer : public IBuffer {
      protected:
        GLuint index;
        GLenum target;
        IIndexedBuffer() : IBuffer(), index(0), target(0) {}
        IIndexedBuffer(GLuint index, GLsizeiptr size, GLbitfield access) : IBuffer(size, NULL, access), index(index) {}

      public:
        void Reset(GLuint index);
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////

    class ATC : public IIndexedBuffer {
      public:
        ATC() = default;
        ATC(GLuint index, GLsizeiptr size, GLbitfield access = GL_DYNAMIC_STORAGE_BIT);
    };

    class SSBO : public IIndexedBuffer {
      public:
        SSBO() = default;
        SSBO(GLuint index, GLsizeiptr size, GLbitfield access = GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT | GL_MAP_WRITE_BIT);
    };

    class UBO : public IIndexedBuffer {
      private:
        using u_vec = std::vector<GLuint>;
        u_vec offset_vec;  // each uniform's aligned byte offset
        u_vec stride_vec;  // each uniform's byte stride (with padding)
        u_vec length_vec;  // each uniform's byte length (w/o. padding)

      public:
        UBO() = default;
        UBO(GLuint index, const u_vec& offset, const u_vec& length, const u_vec& stride);
        UBO(GLuint shader, GLuint block_id, GLbitfield access = GL_DYNAMIC_STORAGE_BIT);
        void SetUniform(GLuint uid, const void* data) const;
        void SetUniform(GLuint fr, GLuint to, const void* data) const;
    };

}
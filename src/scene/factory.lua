--------------------------------------------------------------------------------
-- this file is used to generate C++ code that overwrites `src/scene/factory.h`
--------------------------------------------------------------------------------
local config = _G["CONFIG"]  -- `CONFIG` global variable has all scenes metadata
local count = #(config.title)

print("Generating C++ code for the factory pattern...")

code = [[
#pragma once

// THIS HEADER FILE IS AUTO GENERATED BY LUA SCRIPT, DO NOT TOUCH
// THIS IS A SIMPLE FACTORY PATTERN TO LOAD NEW SCENES AT RUNTIME

// once you have made a new scene, rebuild the solution on the command line
// the content of this file will be automatic updated to reflect the change

#include <iostream>
#include <string>
#include <vector>
#include "core/log.h"
#include "scene/scene.h"
]]  -- multi-line string that ends on a new line

code = code .. "\n"  -- another new line

for i = 1, count do
    local file = config.files[i]
    code = code .. "#include \"" .. "example" .. "/" .. file .. ".h\"\n"
end

code = code .. "\n" .. [[
namespace scene::factory {

    inline const std::vector<std::string> titles {
        "Welcome Screen"]]  -- multi-line string that ends on the same line

for i = 1, count do
    code = code .. ",\n        " .. config.title[i]
end

code = code .. "\n    };\n\n" .. [[
    inline Scene* LoadScene(const std::string& title) {
        if (title == "Welcome Screen") return new Scene(title);
]]  -- multi-line string that ends on a new line

for i = 1, count do
    local title = config.title[i]
    local class = config.class[i]

    code = code .. "        if (title == " .. title
    code = code .. ") return new " .. class .. "(title);\n"
end

code = code .. "\n" .. [[
        CORE_ERROR("Scene \"{0}\" is not registered in the factory ...", title);
        std::cin.get();
        exit(EXIT_FAILURE);
    }
]]

code = code .. "\n" .. "}"

print("Overwriting source file \"src/scene/factory.h\"")

io.writefile("factory.h", code)

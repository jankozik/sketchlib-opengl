//用4倍抗锯齿的话，每个pixel里面会有4个fragment

//transform矩阵很少在GLSL中完成，通常是用GLM在C++代码中算好矩阵, send it to GLSL, 在GLSL里只做multiplication乘法。
//CPU擅长做通用计算。GPU是并行的，GPU对矩阵乘法是优化过的，矩阵乘法都要放在shader里（主要是vertex shader，对每个vertex apply）。

//如何定义各种矩阵：
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtc/matrix_transform.hpp>

glm::mat4 m = glm::mat4(1.0f);  //单位矩阵
glm::mat4 m(1.0f);  //更简单粗暴

glm::mat4 m = glm::translate(glm::mat4(), glm::vec3(10.0f, 0.0f, 0.0f));
glm::vec4 v(10.0f, 10.0f, 10.0f, 0.0f);
glm::vec4 transformedV = m * v;  //translate一个向量

glm::mat4 m = glm::scale(2.0f, 2.0f, 2.0f);  //scale

glm::vec3 myRotationAxis( ??, ??, ??);  // rotate
glm::rotate( angle_in_degrees, myRotationAxis );

// Cumulating transformations
// ORDER matters. Scaling FIRST, and THEN the rotation, and THEN the translation.
TransformedVector = TranslationMatrix * RotationMatrix * ScaleMatrix * OriginalVector;

// 三大转换矩阵 1. Model matrix: Model Space (local) -> World Space (global)
Model_matrix = TranslationMatrix * RotationMatrix * ScaleMatrix;
TransformedVector = Model_matrix * OriginalVector;  // Model Space (local) -> World Space (global)

// 2. View matrix: World Space -> Camera Space
glm::mat4 CameraMatrix = glm::lookAt(
    cameraPosition, // the position of your camera, in world space
    cameraTarget,   // where you want to look at, in world space
    upVector        // probably glm::vec3(0,1,0)
);

// 3. Projection matrix: Camera Space -> Homogeneous Space (the viewing cube, range (-1, 1) in all xyz axes).
// 乘以这个矩阵后，实质上是把所有可见的物体变成相机frustum的形状，而把相机frustum变成我们的viewing cube立方体。
glm::mat4 projectionMatrix = glm::perspective(
    glm::radians(FoV), // The vertical Field of View, in radians
    4.0f / 3.0f,       // Aspect Ratio. Depends on the size of your window. usually 16:9
    0.1f,              // Near clipping plane. Keep as big as possible, or you'll get precision issues.
    100.0f             // Far clipping plane. Keep as little as possible.
);

// 三大矩阵组合起来成为一个大矩阵：the ModelViewProjection matrix，简称MVP矩阵。
glm::mat4 MVP = P * V * M;                  // compute the matrix in C++
transformed_vertex = MVP * in_vertex;       // apply it in GLSL

// step 1. compute the MVP matrix in C++, send it to GLSL
GLuint MVP_uid = glGetUniformLocation(PO, "MVP");  // query location (ONLY ONCE in Init())

glm::mat4 P = glm::perspective(glm::radians(45.0f), (float) width / (float)height, 0.1f, 100.0f);
glm::mat4 P = glm::ortho(-10.0f,10.0f,-10.0f,10.0f,0.0f,100.0f); // In world coordinates
glm::mat4 V = glm::lookAt(
    glm::vec3(4,3,3), // Camera is at (4,3,3), in World Space
    glm::vec3(0,0,0), // and looks at the origin
    glm::vec3(0,1,0)  // Head is up (set to 0,-1,0 to look upside-down)
);
glm::mat4 M = glm::mat4(1.0f);  // Model matrix : an identity matrix (model will be at the origin)
glm::mat4 MVP = P * V * M; // 乘的顺序是反过来的

glUniformMatrix4fv(MVP_uid, 1, GL_FALSE, &MVP[0][0]);  // set the MVP uniform (EVERY FRAME! each model has a different MVP)

// step 2. apply MVP in GLSL
layout(location = 0) in vec3 position;
uniform mat4 MVP;
void main() {
    gl_Position =  MVP * vec4(position, 1.0f);
}

// 经过shader后，GPU硬件中的厂商的OpenGL代码会自动计算"divide by W"的步骤

// VAO是一个用于管理VBO和IBO的对象，VAO中存储着：哪个VBO绑定了什么数据，对应的IBO是什么，等等之类的信息。
// 一个程序至少要有一个VAO，一个VAO可以管理多个VBOIBO。也可以有多个VAO，用于管理不同的要draw的物体。
// 如果只有一个VAO，但是要画多个物体，那么每次draw call之前，都要手动的绑定VBO，设置vertex的attributes，因为每个物体的VBO数据不一样，或是时刻在变化的。当然了，也可以每个物体都有一个单独的VAO，这个VAO包含了draw该物体需要知道的所有VBO,IBO的信息，都是绑定好了的，那么每次draw一个物体前，就只需要把OpenGL状态机的状态bind到这个VAO上就好了，这也是OpenGL推荐的做法。不过，performance上哪种更快没有定论，要根据自己的生产环境去benchmark，profile测试一下性能。不考虑性能的情况下，用多个VAO来管理程序会显得更方便。
glBindVertexArray(VAO);  // 下面的代码的所有bind都会被关联记录到这个VAO中，until这个VAO被解绑为止
//如果只有一个VAO，又有多个draw的物体或者物体VBO是动态的，那么每次draw call前都要加上下面这三行，放在display callback里。
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glEnableVertexAttribArray(0);  // 这里0其实是VAO array中的一个指针
glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);  //这里是告诉VBO我的数据的layout是怎样的，但实际上信息是绑到VAO里的

/*
频幕上最终能看到的vertex全都是在Normalized Device Coordinates (NDC)空间里的，俗称NDC space。它就是xyz三个轴都在[-1,1]之间的一个立方体范围。
vertex shader的最终输出的gl_Position，就是把所有vertex的position转换到NDC空间。
NDC以外的vertex会被clip丢弃掉。
被转换到NDC空间的点，然后会通过glViewport转换为屏幕上的screen-space的点，这些点是最终我们看到的，也是fragment shader的input。

绑着VAO的时候，接下来开始设置VBO和IBO的各种layout，VBO设置好了以后，是可以安全的unbind的，但其实不需要，而IBO设置好了以后，千万不要在解绑VAO之前就unbind，否则刚刚的IBO就白设置了，VAO会抹掉之前的设置信息。
总之统一一下，绑着VAO的时候，再开始绑VBO并设置各种attrib，再绑IBO，记住，VBO和IBO都不要做任何手动unbind的动作，设置完成后直接unbind VAO就好了，这样的话，VAO当中会完整的保存着VBO+IBO的设置信息，并且在VAO解绑的同时它会自动解绑VBO+IBO。最后，每次要draw的时候，就只要bind到对应的VAO就好了。
如果你只draw一个物体，或只有一个VAO的话，每次在display callback里画完了之后也不用glBindVertexArray(0)，多此一举。

对于GLSL shader，const变量是不会被不同的shader stages之间shared的，也就是说，你在vertex shader里定义一个const变量，不会被fragment shader看到，哪怕你在fragment shader定义了一个一模一样的同名变量，那也是另一个变量。
而uniform是会被不同的shader stage之间共享的，假如你在vs和fs中都定义了一个同名的uniform变量，当vs和fs被link起来编译成一个program object的时候，这个program里只会有一个该uniform，换句话说，如果vs中定义了一个uniform A，fs中又定义了一个uniform也叫A，类型声明完全相同，这两个A实际上是同一个uniform变量，所以你只需要在opengl代码中从PO里面query一次这个uniform的location，不用query两次，也只需要给它赋值一次，不用赋两次，你赋值的时候，vs和fs都会同时接收到这个值。
但是，千万要注意，当你的程序里有多个PO，也就是有多个不同的shader program，这些program之间是完全独立的，他们里面的任何同名变量都不会被share，所以你在query location和赋值的时候，要对每个PO都分别操作一次。

// add this mode when you are working with the Mesh chapter
glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);  // draw wireframe
glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

















*/



















































// 争取把opengl官方tutorial都过一遍，然后加上GLDebugMessageCallback
// 然后把CSC461的东西加进来，还有antongerdelan的教程（比较简单）
// 中途一边把cherno的opengl视频概念全都看一遍

// paroj的那个教程是讲底层的，实际上不需要自己手动做那么多事，读一下看看概念就可以了

// alili的作业然后再做
// 所有opengl的东西，这个repo，争取赶在春假结束前全部搞定，然后做mana oasis

// 后面别折腾opengl，有时间都去留给GLSL，写shader









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































//end
